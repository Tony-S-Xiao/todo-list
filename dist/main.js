/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@datastructures-js/binary-search-tree/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@datastructures-js/binary-search-tree/index.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const BinarySearchTree = __webpack_require__(/*! ./src/binarySearchTree */ \"./node_modules/@datastructures-js/binary-search-tree/src/binarySearchTree.js\");\nconst AvlTree = __webpack_require__(/*! ./src/avlTree */ \"./node_modules/@datastructures-js/binary-search-tree/src/avlTree.js\");\n\nmodule.exports = { BinarySearchTree, AvlTree };\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/binary-search-tree/index.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/binary-search-tree/src/avlTree.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@datastructures-js/binary-search-tree/src/avlTree.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @datastructures-js/binary-search-tree\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst BinarySearchTree = __webpack_require__(/*! ./binarySearchTree */ \"./node_modules/@datastructures-js/binary-search-tree/src/binarySearchTree.js\");\nconst AvlTreeNode = __webpack_require__(/*! ./avlTreeNode */ \"./node_modules/@datastructures-js/binary-search-tree/src/avlTreeNode.js\");\n\n/**\n * @class AvlTree\n * @extends BinarySearchTree\n */\nclass AvlTree extends BinarySearchTree {\n  /**\n   * @private\n   * applies the proper rotation on a node during insert or remove\n   * @param {AvlTreeNode} node\n   */\n  _balanceNode(node) {\n    if (!node) return;\n\n    node.updateHeight();\n    const balance = node.calculateBalance();\n    if (balance > 1) {\n      if (node.getLeft().getLeft() !== null) {\n        node.rotateRight();\n      } else if (node.getLeft().getRight() !== null) {\n        node.rotateLeftRight();\n      }\n    } else if (balance < -1) {\n      if (node.getRight().getRight() !== null) {\n        node.rotateLeft();\n      } else if (node.getRight().getLeft() !== null) {\n        node.rotateRightLeft();\n      }\n    }\n    if (node === this._root && (balance < -1 || balance > 1)) {\n      this._root = node.getParent();\n    }\n  }\n\n  /**\n   * @public\n   * inserts a node with a key/value into tree\n   * and maintains the tree balanced by applying the necessary rotations\n   * @param {number|string} key\n   * @param {object} value\n   * @param {AvlTreeNode} node\n   * @return {AvlTreeNode} the inserted node\n   */\n  insert(key, value, node = this._root) {\n    if (node === null) {\n      this._root = new AvlTreeNode(key, value);\n      this._count += 1;\n      return this._root;\n    }\n\n    if (key < node.getKey() && node.getLeft() === null) {\n      const newNode = new AvlTreeNode(key, value);\n      node.setLeft(newNode);\n      newNode.setParent(node);\n      node.updateHeight();\n      this._count += 1;\n      return newNode;\n    }\n\n    if (key > node.getKey() && node.getRight() === null) {\n      const newNode = new AvlTreeNode(key, value);\n      node.setRight(newNode);\n      newNode.setParent(node);\n      node.updateHeight();\n      this._count += 1;\n      return newNode;\n    }\n\n    if (key === node.getKey()) {\n      node.setValue(value);\n      return node;\n    }\n\n    if (key < node.getKey()) {\n      const newNode = this.insert(key, value, node.getLeft());\n      this._balanceNode(node); // backward-tracking\n      return newNode;\n    }\n\n    const newNode = this.insert(key, value, node.getRight());\n    this._balanceNode(node); // backward-tracking\n    return newNode;\n  }\n\n  /**\n   * @public\n   * remove a node by its key\n   * and maintains the tree balanced by applying the necessary rotations\n   * @param {number|string} key\n   * @param {AvlTreeNode} node\n   * @return {boolean}\n   */\n  remove(key, node = this._root) {\n    if (node === null) return false;\n\n    if (key < node.getKey()) {\n      const removed = this.remove(key, node.getLeft());\n      this._balanceNode(node);\n      return removed;\n    }\n\n    if (key > node.getKey()) {\n      const removed = this.remove(key, node.getRight());\n      this._balanceNode(node);\n      return removed;\n    }\n\n    if (node.getLeft() === null && node.getRight() === null) {\n      if (node.getParent() === null) {\n        this._root = null;\n      } else if (key < node.getParent().getKey()) {\n        node.getParent().setLeft(null);\n        node.getParent().updateHeight();\n      } else {\n        node.getParent().setRight(null);\n        node.getParent().updateHeight();\n      }\n      this._count -= 1;\n      return true;\n    }\n\n    if (node.getRight() === null) {\n      if (node.getParent() === null) {\n        this._root = node.getLeft();\n      } else if (key < node.getParent().getKey()) {\n        node.getParent().setLeft(node.getLeft());\n        node.getParent().updateHeight();\n      } else {\n        node.getParent().setRight(node.getLeft());\n        node.getParent().updateHeight();\n      }\n      node.getLeft().setParent(node.getParent());\n      this._count -= 1;\n      return true;\n    }\n\n    if (node.getLeft() === null) {\n      if (node.getParent() === null) {\n        this._root = node.getRight();\n      } else if (key < node.getParent().getKey()) {\n        node.getParent().setLeft(node.getRight());\n        node.getParent().updateHeight();\n      } else {\n        node.getParent().setRight(node.getRight());\n        node.getParent().updateHeight();\n      }\n      node.getRight().setParent(node.getParent());\n      this._count -= 1;\n      return true;\n    }\n\n    const minRight = this.min(node.getRight());\n    node.setKey(minRight.getKey());\n    return this.remove(minRight.getKey(), minRight);\n  }\n}\n\nmodule.exports = AvlTree;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/binary-search-tree/src/avlTree.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/binary-search-tree/src/avlTreeNode.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@datastructures-js/binary-search-tree/src/avlTreeNode.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @datastructures-js/binary-search-tree\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst BinarySearchTreeNode = __webpack_require__(/*! ./binarySearchTreeNode */ \"./node_modules/@datastructures-js/binary-search-tree/src/binarySearchTreeNode.js\");\n\n/**\n * @class AvlTreeNode\n * @extends BinarySearchTreeNode\n */\nclass AvlTreeNode extends BinarySearchTreeNode {\n  constructor(key, value) {\n    super(key, value);\n    this._height = 1;\n  }\n\n  /**\n   * @internal\n   * rotates left (counter-clockwise) and updates parent and children\n   */\n  rotateLeft() {\n    const right = this.getRight(); // this._right will be re-assigned\n\n    // set the node as a left child of its right child\n    if (right !== null) {\n      if (right.getLeft() !== null) {\n        right.getLeft().setParent(this);\n      }\n\n      // rebase right child to node's right left child.\n      this._right = right.getLeft();\n\n      right.setLeft(this);\n      right.setParent(this._parent);\n    }\n\n    // rebase parent's child to node's right child\n    if (this._parent !== null && right !== null) {\n      if (this._parent.getKey() < right.getKey()) {\n        this._parent.setRight(right);\n      } else {\n        this._parent.setLeft(right);\n      }\n    }\n\n    // rebase parent to node's right child\n    this._parent = right;\n\n    this.updateHeight();\n    if (this._parent !== null) {\n      this._parent.updateHeight();\n    }\n  }\n\n  /**\n   * @internal\n   * rotates right (clockwise) and updates parent and children\n   */\n  rotateRight() {\n    const left = this.getLeft(); // this._left will be re-assigned\n\n    // set the node as a right child of its left child\n    if (left !== null) {\n      if (left.getRight() !== null) {\n        left.getRight().setParent(this);\n      }\n\n      // rebase right child to node's right left child.\n      this._left = left.getRight();\n\n      left.setRight(this);\n      left.setParent(this._parent);\n    }\n\n    // rebase parent to node's left child\n    if (this._parent !== null && left !== null) {\n      if (this._parent.getKey() > left.getKey()) {\n        this._parent.setLeft(left);\n      } else {\n        this._parent.setRight(left);\n      }\n    }\n\n    // rebase parent to node's right child\n    this._parent = left;\n\n    this.updateHeight();\n    if (this._parent !== null) {\n      this._parent.updateHeight();\n    }\n  }\n\n  /**\n   * @internal\n   * rotates left child to left then itself to right\n   */\n  rotateLeftRight() {\n    if (this._left !== null) {\n      this._left.rotateLeft();\n    }\n    this.rotateRight();\n  }\n\n  /**\n   * @internal\n   * rotates right child to right then itself to left\n   */\n  rotateRightLeft() {\n    if (this._right !== null) {\n      this._right.rotateRight();\n    }\n    this.rotateLeft();\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  getLeftHeight() {\n    return this._left !== null ? this._left.getHeight() : 0;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  getRightHeight() {\n    return this._right !== null ? this._right.getHeight() : 0;\n  }\n\n  /**\n   * @internal\n   * updates the height of a node as the max height of its children\n   */\n  updateHeight() {\n    this._height = Math.max(this.getLeftHeight(), this.getRightHeight()) + 1;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  getHeight() {\n    return this._height;\n  }\n\n  /**\n   * @public\n   * calculate the balance of a node as the diff between left & right heights\n   * @return {number}\n   */\n  calculateBalance() {\n    return this.getLeftHeight() - this.getRightHeight();\n  }\n}\n\nmodule.exports = AvlTreeNode;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/binary-search-tree/src/avlTreeNode.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/binary-search-tree/src/binarySearchTree.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@datastructures-js/binary-search-tree/src/binarySearchTree.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @datastructures-js/binary-search-tree\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst BinarySearchTreeNode = __webpack_require__(/*! ./binarySearchTreeNode */ \"./node_modules/@datastructures-js/binary-search-tree/src/binarySearchTreeNode.js\");\n\n/**\n * @class BinarySearchTree\n */\nclass BinarySearchTree {\n  constructor() {\n    this._root = null;\n    this._count = 0;\n  }\n\n  /**\n   * @public\n   * inserts a node with a key/value into the tree\n   * @param {number|string} key\n   * @param {object} value\n   * @param {BinarySearchTreeNode} node\n   * @return {BinarySearchTreeNode}\n   */\n  insert(key, value, node = this._root) {\n    if (node === null) {\n      this._root = new BinarySearchTreeNode(key, value);\n      this._count += 1;\n      return this._root;\n    }\n\n    if (key < node.getKey() && node.getLeft() === null) {\n      const newNode = new BinarySearchTreeNode(key, value);\n      node.setLeft(newNode);\n      newNode.setParent(node);\n      this._count += 1;\n      return newNode;\n    }\n\n    if (key > node.getKey() && node.getRight() === null) {\n      const newNode = new BinarySearchTreeNode(key, value);\n      node.setRight(newNode);\n      newNode.setParent(node);\n      this._count += 1;\n      return newNode;\n    }\n\n    if (key === node.getKey()) {\n      node.setValue(value);\n      return node;\n    }\n\n    if (key < node.getKey()) {\n      return this.insert(key, value, node.getLeft());\n    }\n\n    return this.insert(key, value, node.getRight());\n  }\n\n  /**\n   * @public\n   * check if a value exists in the tree by its key\n   * @param {number|string} key\n   * @param {BinarySearchTreeNode} node\n   * @return {boolean}\n   */\n  has(key, node = this._root) {\n    if (node === null) return false;\n\n    if (key === node.getKey()) return true;\n\n    if (key < node.getKey()) return this.has(key, node.getLeft());\n\n    return this.has(key, node.getRight());\n  }\n\n  /**\n   * @public\n   * finds the key's node in the tree\n   * @param {number|string} key\n   * @param {BinarySearchTreeNode} node\n   * @return {BinarySearchTreeNode}\n   */\n  find(key, node = this._root) {\n    if (node === null) return null;\n\n    if (key === node.getKey()) return node;\n\n    if (key < node.getKey()) return this.find(key, node.getLeft());\n\n    return this.find(key, node.getRight());\n  }\n\n  /**\n   * @public\n   * finds the node with max key (most right) in the tree\n   * @param {BinarySearchTreeNode} node\n   * @return {BinarySearchTreeNode}\n   */\n  max(node = this._root) {\n    if (node === null) return null;\n\n    if (node.getRight() === null) return node;\n\n    return this.max(node.getRight());\n  }\n\n  /**\n   * @public\n   * finds the node with min key (most left) in the tree\n   * @param {BinarySearchTreeNode} node\n   * @return {BinarySearchTreeNode}\n   */\n  min(node = this._root) {\n    if (node === null) return null;\n\n    if (node.getLeft() === null) return node;\n\n    return this.min(node.getLeft());\n  }\n\n  /**\n   * @public\n   * returns the tree root node\n   * @return {BinarySearchTreeNode}\n   */\n  root() {\n    return this._root;\n  }\n\n  /**\n   * @public\n   * returns the nodes count in the tree\n   * @return {number}\n   */\n  count() {\n    return this._count;\n  }\n\n  /**\n   * @public\n   * remove a node by its key\n   * @param {number|string} key\n   * @param {BinarySearchTreeNode} node\n   * @return {boolean}\n   */\n  remove(key, node = this._root) {\n    if (node === null) return false;\n\n    if (key < node.getKey()) {\n      return this.remove(key, node.getLeft());\n    }\n\n    if (key > node.getKey()) {\n      return this.remove(key, node.getRight());\n    }\n\n    if (node.getLeft() === null && node.getRight() === null) {\n      if (node.getParent() === null) {\n        this._root = null;\n      } else if (node.getKey() < node.getParent().getKey()) {\n        node.getParent().setLeft(null);\n      } else {\n        node.getParent().setRight(null);\n      }\n      this._count -= 1;\n      return true;\n    }\n\n    if (node.getRight() === null) {\n      if (node.getParent() === null) {\n        this._root = node.getLeft();\n      } else if (node.getKey() < node.getParent().getKey()) {\n        node.getParent().setLeft(node.getLeft());\n      } else {\n        node.getParent().setRight(node.getLeft());\n      }\n      node.getLeft().setParent(node.getParent());\n      this._count -= 1;\n      return true;\n    }\n\n    if (node.getLeft() === null) {\n      if (node.getParent() === null) {\n        this._root = node.getRight();\n      } else if (node.getKey() < node.getParent().getKey()) {\n        node.getParent().setLeft(node.getRight());\n      } else {\n        node.getParent().setRight(node.getRight());\n      }\n      node.getRight().setParent(node.getParent());\n      this._count -= 1;\n      return true;\n    }\n\n    const minRight = this.min(node.getRight());\n    node.setKey(minRight.getKey());\n    node.setValue(minRight.getValue());\n    return this.remove(minRight.getKey(), minRight);\n  }\n\n  /**\n   * @public\n   * traverse the tree in-order (left-node-right)\n   * @param {function} cb\n   * @param {BinarySearchTreeNode} node\n   */\n  traverseInOrder(cb, node = this._root) {\n    if (typeof cb !== 'function') {\n      throw new Error('.traverseInOrder(cb) expects a callback');\n    }\n\n    if (node === null) return;\n\n    this.traverseInOrder(cb, node.getLeft());\n    cb(node);\n    this.traverseInOrder(cb, node.getRight());\n  }\n\n  /**\n   * @public\n   * traverse the tree pre-order (node-left-right)\n   * @param {function} cb\n   * @param {BinarySearchTreeNode} node\n   */\n  traversePreOrder(cb, node = this._root) {\n    if (typeof cb !== 'function') {\n      throw new Error('.traversePreOrder(cb) expects a callback');\n    }\n\n    if (node === null) return;\n\n    cb(node);\n    this.traversePreOrder(cb, node.getLeft());\n    this.traversePreOrder(cb, node.getRight());\n  }\n\n  /**\n   * @public\n   * traverse the tree post-order (left-right-node)\n   * @param {function} cb\n   * @param {BinarySearchTreeNode} node\n   */\n  traversePostOrder(cb, node = this._root) {\n    if (typeof cb !== 'function') {\n      throw new Error('.traversePostOrder(cb) expects a callback');\n    }\n\n    if (node === null) return;\n\n    this.traversePostOrder(cb, node.getLeft());\n    this.traversePostOrder(cb, node.getRight());\n    cb(node);\n  }\n\n  /**\n   * @public\n   * clears the tree\n   */\n  clear() {\n    this._root = null;\n    this._count = 0;\n  }\n}\n\nmodule.exports = BinarySearchTree;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/binary-search-tree/src/binarySearchTree.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/binary-search-tree/src/binarySearchTreeNode.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@datastructures-js/binary-search-tree/src/binarySearchTreeNode.js ***!
  \****************************************************************************************/
/***/ ((module) => {

eval("/**\n * @datastructures-js/binary-search-tree\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\n/**\n * @class BinarySearchTreeNode\n */\nclass BinarySearchTreeNode {\n  constructor(key, value) {\n    this._key = key;\n    this._value = value;\n    this._left = null;\n    this._right = null;\n    this._parent = null;\n  }\n\n  /**\n   * @internal\n   * @param {number|string}\n   */\n  setKey(key) {\n    this._key = key;\n  }\n\n  /**\n   * @public\n   * @return {number|string}\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * @public\n   * @param {object}\n   */\n  setValue(value) {\n    this._value = value;\n  }\n\n  /**\n   * @public\n   * @return {object}\n   */\n  getValue() {\n    return this._value;\n  }\n\n  /**\n   * @internal\n   * @param {BinarySearchTreeNode}\n   */\n  setLeft(left) {\n    this._left = left;\n  }\n\n  /**\n   * @public\n   * @return {BinarySearchTreeNode}\n   */\n  getLeft() {\n    return this._left;\n  }\n\n  /**\n   * @internal\n   * @param {BinarySearchTreeNode}\n   */\n  setRight(right) {\n    this._right = right;\n  }\n\n  /**\n   * @public\n   * @return {BinarySearchTreeNode}\n   */\n  getRight() {\n    return this._right;\n  }\n\n  /**\n   * @internal\n   * @param {BinarySearchTreeNode}\n   */\n  setParent(parent) {\n    this._parent = parent;\n  }\n\n  /**\n   * @public\n   * @return {BinarySearchTreeNode}\n   */\n  getParent() {\n    return this._parent;\n  }\n}\n\nmodule.exports = BinarySearchTreeNode;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/binary-search-tree/src/binarySearchTreeNode.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/graph/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@datastructures-js/graph/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Graph = __webpack_require__(/*! ./src/graph */ \"./node_modules/@datastructures-js/graph/src/graph.js\");\nconst DirectedGraph = __webpack_require__(/*! ./src/directedGraph */ \"./node_modules/@datastructures-js/graph/src/directedGraph.js\");\n\nmodule.exports = { Graph, DirectedGraph };\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/graph/index.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/graph/src/directedGraph.js":
/*!********************************************************************!*\
  !*** ./node_modules/@datastructures-js/graph/src/directedGraph.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @datastructures-js/graph\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst Queue = __webpack_require__(/*! @datastructures-js/queue */ \"./node_modules/@datastructures-js/queue/index.js\");\nconst Vertex = __webpack_require__(/*! ./vertex */ \"./node_modules/@datastructures-js/graph/src/vertex.js\");\n\n/**\n * @class DirectedGraph\n * A graph with a directed path between vertices\n */\nclass DirectedGraph {\n  constructor() {\n    this._vertices = new Map();\n    this._edges = new Map();\n    this._edgesCount = 0;\n  }\n\n  /**\n   * @public\n   * adds a vertex to the graph\n   * @param {number|string} key\n   * @param {object} value\n   * @returns {Vertex}\n   */\n  addVertex(key, value) {\n    this._vertices.set(key, new Vertex(key, value));\n    if (!this._edges.has(key)) {\n      this._edges.set(key, new Map());\n    }\n    return this._vertices.get(key);\n  }\n\n  /**\n   * @public\n   * checks if the graph has a vertex by its key\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  hasVertex(key) {\n    return this._vertices.has(key);\n  }\n\n  /**\n   * @public\n   * remove a vertex and all its in and out edges\n   * @param {number|string} key\n   */\n  removeVertex(key) {\n    if (!this.hasVertex(key)) return false;\n\n    this.removeEdges(key);\n    this._edges.delete(key);\n    this._vertices.delete(key);\n    return true;\n  }\n\n  /**\n   * @public\n   * the number of vertices in the graph\n   * @returns {number}\n   */\n  verticesCount() {\n    return this._vertices.size;\n  }\n\n  /**\n   * @public\n   * add a direction from source to destination\n   * @param {number|string} srcKey\n   * @param {number|string} destKey\n   * @param {number} weight\n   * @throws {Error} if a vertex key does not exist\n   */\n  addEdge(srcKey, destKey, weight) {\n    if (!this._vertices.has(srcKey)) {\n      throw new Error(`addEdge: vertex \"${srcKey}\" not found`);\n    }\n\n    if (!this._vertices.has(destKey)) {\n      throw new Error(`addEdge: vertex \"${destKey}\" not found`);\n    }\n\n    this._edges.get(srcKey).set(destKey, +weight || 1);\n    this._edgesCount += 1;\n  }\n\n  /**\n   * @public\n   * checks if there is a direction from source to destination\n   * @param {number|string} srcKey\n   * @param {number|string} destKey\n   * @returns {boolean}\n   */\n  hasEdge(srcKey, destKey) {\n    return this.hasVertex(srcKey)\n      && this.hasVertex(destKey)\n      && this._edges.get(srcKey).has(destKey);\n  }\n\n  /**\n   * @public\n   * get the weight of an edge if exists\n   * @param {number|string} srcKey\n   * @param {number|string} destKey\n   * @returns {number}\n   */\n  getWeight(srcKey, destKey) {\n    if (this.hasVertex(srcKey) && srcKey === destKey) return 0;\n    if (!this.hasEdge(srcKey, destKey)) return null;\n    return this._edges.get(srcKey).get(destKey);\n  }\n\n  /**\n   * @public\n   * removes the direction from source to destination\n   * @param {number|string} srcKey\n   * @param {number|string} destKey\n   */\n  removeEdge(srcKey, destKey) {\n    if (!this.hasEdge(srcKey, destKey)) return false;\n\n    this._edges.get(srcKey).delete(destKey);\n    this._edgesCount -= 1;\n    return true;\n  }\n\n  /**\n   * @public\n   * removes all directions from and to a vertex\n   * @param {number|string} key\n   * @return {number} number of removed edges\n   */\n  removeEdges(key) {\n    if (!this.hasVertex(key)) return 0;\n\n    let removed = 0;\n    this._edges.forEach((destEdges, srcKey) => {\n      if (destEdges.has(key)) {\n        this.removeEdge(srcKey, key);\n        removed += 1;\n      }\n    });\n\n    removed += this._edges.get(key).size;\n    this._edgesCount -= this._edges.get(key).size;\n    this._edges.set(key, new Map());\n    return removed;\n  }\n\n  /**\n   * @public\n   * the number of directions in the graph\n   * @returns {number}\n   */\n  edgesCount() {\n    return this._edgesCount;\n  }\n\n  /**\n   * @public\n   * traverse all vertices in the graph using depth-first search\n   * @param {number|string} srcKey\n   * @param {function} cb\n   */\n  traverseDfs(srcKey, cb, visited = new Set()) {\n    if (!this.hasVertex(srcKey) || visited.has(srcKey)) return;\n\n    cb(this._vertices.get(srcKey));\n    visited.add(srcKey);\n\n    this._edges.get(srcKey).forEach((weight, destKey) => {\n      this.traverseDfs(destKey, cb, visited);\n    });\n  }\n\n  /**\n   * @public\n   * traverse all vertices in the graph using breadth-first search\n   * @param {number|string} srcKey\n   * @param {function} cb\n   */\n  traverseBfs(srcKey, cb) {\n    if (!this.hasVertex(srcKey)) return;\n\n    const queue = new Queue([srcKey]);\n    const visited = new Set([srcKey]);\n\n    while (!queue.isEmpty()) {\n      const vertex = this._vertices.get(queue.dequeue());\n      cb(vertex);\n      this._edges.get(vertex.getKey()).forEach((weight, destKey) => {\n        if (visited.has(destKey)) return;\n        queue.enqueue(destKey);\n        visited.add(destKey);\n      });\n    }\n  }\n\n  /**\n   * @public\n   * clears the graph\n   */\n  clear() {\n    this._vertices = new Map();\n    this._edges = new Map();\n    this._edgesCount = 0;\n  }\n}\n\nmodule.exports = DirectedGraph;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/graph/src/directedGraph.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/graph/src/graph.js":
/*!************************************************************!*\
  !*** ./node_modules/@datastructures-js/graph/src/graph.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @datastructures-js/graph\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst DirectedGraph = __webpack_require__(/*! ./directedGraph */ \"./node_modules/@datastructures-js/graph/src/directedGraph.js\");\n\n/**\n * @class Graph\n * @extends DirectedGraph\n * A graph with a connecting edge between vertices\n */\nclass Graph extends DirectedGraph {\n  /**\n   * @public\n   * @override\n   * removes all edges of a vertex\n   * @param {number|string} key\n   * @return {number} number of removed edges\n   */\n  removeEdges(key) {\n    if (!this.hasVertex(key)) return 0;\n\n    let removed = 0;\n    this._edges.get(key).forEach((weight, destKey) => {\n      this.removeEdge(destKey, key);\n      removed += 1;\n    });\n\n    this._edgesCount -= this._edges.get(key).size;\n    this._edges.set(key, new Map());\n    return removed;\n  }\n\n  /**\n   * @public\n   * @override\n   * add a connecting edge between two vertices\n   * @param {number|string} srcKey\n   * @param {number|string} destKey\n   * @param {number} weight\n   * @throws {Error} if a vertex key does not exist\n   */\n  addEdge(sourceKey, destKey, weight) {\n    super.addEdge(sourceKey, destKey, weight);\n    super.addEdge(destKey, sourceKey, weight);\n  }\n\n  /**\n   * @public\n   * @override\n   * removes the connecting edge between two vertices\n   * @param {number|string} srcKey\n   * @param {number|string} destKey\n   * @returns {boolean}\n   */\n  removeEdge(sourceKey, destKey) {\n    super.removeEdge(sourceKey, destKey);\n    return super.removeEdge(destKey, sourceKey);\n  }\n\n  /**\n   * @public\n   * @override\n   * the number of connecting edges in the graph\n   * @returns {number}\n   */\n  edgesCount() {\n    return super.edgesCount() / 2;\n  }\n}\n\nmodule.exports = Graph;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/graph/src/graph.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/graph/src/vertex.js":
/*!*************************************************************!*\
  !*** ./node_modules/@datastructures-js/graph/src/vertex.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("/**\n * @class Vertex\n * represents the node in a graph\n */\nclass Vertex {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  /**\n   * @public\n   * @returns {number|string}\n   */\n  getKey() {\n    return this.key;\n  }\n\n  /**\n   * @public\n   * @returns {object}\n   */\n  getValue() {\n    return this.value;\n  }\n}\n\nmodule.exports = Vertex;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/graph/src/vertex.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/heap/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@datastructures-js/heap/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const MinHeap = __webpack_require__(/*! ./src/minHeap */ \"./node_modules/@datastructures-js/heap/src/minHeap.js\");\nconst MaxHeap = __webpack_require__(/*! ./src/maxHeap */ \"./node_modules/@datastructures-js/heap/src/maxHeap.js\");\n\nmodule.exports = {\n  MinHeap,\n  MaxHeap\n};\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/heap/index.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/heap/src/heap.js":
/*!**********************************************************!*\
  !*** ./node_modules/@datastructures-js/heap/src/heap.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @datastructures-js/heap\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst HeapNode = __webpack_require__(/*! ./heapNode */ \"./node_modules/@datastructures-js/heap/src/heapNode.js\");\n\nconst isNumber = (n) => typeof n === 'number';\nconst isNoneEmptyString = (s) => typeof s === 'string' && s.length;\nconst isNoneNullObject = (o) => typeof o === 'object' && o !== null;\nconst isNoneEmptyArray = (a) => Array.isArray(a) && a.length > 0;\n\n/**\n * @class Heap\n * @abstract\n */\nclass Heap {\n  constructor(nodes) {\n    this._nodes = Array.isArray(nodes) ? nodes : [];\n    this._leaf = null;\n  }\n\n  /**\n   * @private\n   * calculates the left child's index of a parent's index\n   * @param {number} parentIndex\n   * @returns {number}\n   */\n  _getLeftChildIndex(parentIndex) {\n    return (parentIndex * 2) + 1;\n  }\n\n  /**\n   * @private\n   * calculates the right child's index of a parent's index\n   * @param {number} parentIndex\n   * @returns {number}\n   */\n  _getRightChildIndex(parentIndex) {\n    return (parentIndex * 2) + 2;\n  }\n\n  /**\n   * @private\n   * calculates a parent's index from a child's index\n   * @param {number} parentIndex\n   * @returns {number}\n   */\n  _getParentIndex(childIndex) {\n    return Math.floor((childIndex - 1) / 2);\n  }\n\n  /**\n   * @private\n   * gets the last node's index\n   * @returns {number}\n   */\n  _getLastIndex() {\n    return this._nodes.length - 1;\n  }\n\n  /**\n   * swaps two nodes in the heap by their indices\n   * @param {number} i\n   * @param {number} j\n   */\n  _swap(i, j) {\n    const temp = this._nodes[i];\n    this._nodes[i] = this._nodes[j];\n    this._nodes[j] = temp;\n  }\n\n  /**\n   * @private\n   * selects the proper child's index to fix the heap\n   * @param {number} parentIndex\n   * @returns {number}\n   */\n  _compareChildrenOf(parentIndex) {\n    const leftChildIndex = this._getLeftChildIndex(parentIndex);\n    const rightChildIndex = this._getRightChildIndex(parentIndex);\n    const size = this.size();\n\n    if (leftChildIndex >= size && rightChildIndex >= size) return -1;\n    if (leftChildIndex >= size) return rightChildIndex;\n    if (rightChildIndex >= size) return leftChildIndex;\n\n    return this._compareChildren(leftChildIndex, rightChildIndex);\n  }\n\n  /**\n   * @private\n   * bubbles the last inserted node up in the heap\n   */\n  _heapifyUp() {\n    let childIndex = this._getLastIndex();\n    let parentIndex = this._getParentIndex(childIndex);\n\n    while (this._shouldSwap(childIndex, parentIndex)) {\n      this._swap(childIndex, parentIndex);\n      childIndex = parentIndex;\n      parentIndex = this._getParentIndex(childIndex);\n    }\n  }\n\n  /**\n   * @private\n   * pushes the replaced root node down in the heap after root's removal\n   */\n  _heapifyDown() {\n    let parentIndex = 0;\n    let childIndex = this._compareChildrenOf(parentIndex);\n    while (this._shouldSwap(childIndex, parentIndex)) {\n      this._swap(childIndex, parentIndex);\n      parentIndex = childIndex;\n      childIndex = this._compareChildrenOf(parentIndex);\n    }\n  }\n\n  /**\n   * @private\n   * pushes the swapped node with root down in its correct location\n   * @param {number} i -  swapped node's index\n   */\n  _heapifyDownUntil(index) {\n    let parentIndex = 0;\n    let leftChildIndex = 1;\n    let rightChildIndex = 2;\n    let childIndex;\n\n    while (leftChildIndex < index) {\n      childIndex = this._compareChildrenBefore(\n        index,\n        leftChildIndex,\n        rightChildIndex\n      );\n\n      if (this._shouldSwap(childIndex, parentIndex)) {\n        this._swap(childIndex, parentIndex);\n      }\n\n      parentIndex = childIndex;\n      leftChildIndex = this._getLeftChildIndex(parentIndex);\n      rightChildIndex = this._getRightChildIndex(parentIndex);\n    }\n  }\n\n  /**\n   * @protected\n   * returns a shallow copy of a heap\n   * @param {class} HeapType\n   * @returns {Heap}\n   */\n  _clone(HeapType) {\n    return new HeapType(this._nodes.slice());\n  }\n\n  /**\n   * @public\n   * implements heap sort algorithm by swapping root with i nodes\n   * @returns {array} the sorted nodes\n   */\n  sort() {\n    for (let i = this._getLastIndex(); i > 0; i -= 1) {\n      this._swap(0, i);\n      this._heapifyDownUntil(i);\n    }\n\n    return this._nodes;\n  }\n\n  /**\n   * @public\n   * inserts a node into the heap\n   * @param {number|string} key\n   * @param {object} value\n   * @returns {HeapNode}\n   */\n  insert(key, value) {\n    const newNode = new HeapNode(key, value);\n    this._nodes.push(newNode);\n    this._heapifyUp();\n    return newNode;\n  }\n\n  /**\n   * @public\n   * returns the root node in the heap\n   * @returns {HeapNode}\n   */\n  root() {\n    if (this.isEmpty()) return null;\n    return this._nodes[0];\n  }\n\n  /**\n   * @public\n   * returns a leaf node in the heap\n   * @returns {HeapNode}\n   */\n  leaf() {\n    return this._leaf;\n  }\n\n  /**\n   * @public\n   * removes and returns the root node in the heap\n   * @returns {HeapNode}\n   */\n  extractRoot() {\n    if (this.isEmpty()) return null;\n\n    const root = this.root();\n    this._nodes[0] = this._nodes[this._getLastIndex()];\n    this._nodes.pop();\n    this._heapifyDown();\n\n    if (root === this._leaf) {\n      if (this.isEmpty()) {\n        this._leaf = null;\n      } else {\n        this._leaf = this.root();\n      }\n    }\n\n    return root;\n  }\n\n  /**\n   * @public\n   * returns the number of nodes in the heap\n   * @returns {number}\n   */\n  size() {\n    return this._nodes.length;\n  }\n\n  /**\n   * @public\n   * checks if the heap is empty\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  /**\n   * @public\n   * clears the heap\n   */\n  clear() {\n    this._nodes = [];\n    this._leaf = null;\n  }\n\n  /**\n   * @protected\n   * @static\n   * convert a list of items into a heap\n   * @param {array} items\n   * @param {class} HeapType\n   * @returns {Heap}\n   */\n  static _heapify(items, HeapType) {\n    if (!isNoneEmptyArray(items)) return null;\n\n    const heap = new HeapType();\n    items.forEach((item) => {\n      if (isNumber(item) || isNoneEmptyString(item)) {\n        heap.insert(item);\n      } else if (isNoneNullObject(item)\n        && (isNumber(item.key) || isNoneEmptyString(item.key))) {\n        heap.insert(item.key, item.value);\n      }\n    });\n\n    return heap;\n  }\n}\n\nmodule.exports = Heap;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/heap/src/heap.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/heap/src/heapNode.js":
/*!**************************************************************!*\
  !*** ./node_modules/@datastructures-js/heap/src/heapNode.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("/**\n * @datastructures-js/heap\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\n/**\n * @class HeapNode\n */\nclass HeapNode {\n  constructor(key, value) {\n    this._key = key;\n    this._value = value;\n  }\n\n  /**\n   * @public\n   * @returns {number|string}\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * @public\n   * @returns {object}\n   */\n  getValue() {\n    return this._value;\n  }\n}\n\nmodule.exports = HeapNode;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/heap/src/heapNode.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/heap/src/maxHeap.js":
/*!*************************************************************!*\
  !*** ./node_modules/@datastructures-js/heap/src/maxHeap.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @datastructures-js/heap\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst Heap = __webpack_require__(/*! ./heap */ \"./node_modules/@datastructures-js/heap/src/heap.js\");\n\n/**\n * @class MaxHeap\n * @extends Heap\n */\nclass MaxHeap extends Heap {\n  /**\n   * @private\n   * gets the max child's index of two node's children\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _getMaxChildIndex(leftChildIndex, rightChildIndex) {\n    const leftChild = this._nodes[leftChildIndex];\n    const rightChild = this._nodes[rightChildIndex];\n    if (leftChild.getKey() > rightChild.getKey()) {\n      return leftChildIndex;\n    }\n    return rightChildIndex;\n  }\n\n  /**\n   * @private\n   * returns the max child's index of two children before an index\n   * @param {number} index\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _getMaxChildIndexBefore(index, leftChildIndex, rightChildIndex) {\n    const leftChild = this._nodes[leftChildIndex];\n    const rightChild = this._nodes[rightChildIndex];\n    if (rightChild.getKey() > leftChild.getKey() && rightChildIndex < index) {\n      return rightChildIndex;\n    }\n    return leftChildIndex;\n  }\n\n  /**\n   * @protected\n   * checks if child's key is bigger that its parent's key\n   * @returns {boolean}\n   */\n  _shouldSwap(childIndex, parentIndex) {\n    if (childIndex < 0 || childIndex >= this.size()) return false;\n    if (parentIndex < 0 || parentIndex >= this.size()) return false;\n\n    const child = this._nodes[childIndex];\n    const parent = this._nodes[parentIndex];\n\n    return child.getKey() > parent.getKey();\n  }\n\n  /**\n   * @protected\n   * @override\n   * implements the parent's function to select a child's index\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _compareChildren(leftChildIndex, rightChildIndex) {\n    return this._getMaxChildIndex(leftChildIndex, rightChildIndex);\n  }\n\n  /**\n   * @protected\n   * @override\n   * implements the parent's function to select a child's index before an index\n   * @param {number} index\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _compareChildrenBefore(index, leftChildIndex, rightChildIndex) {\n    return this._getMaxChildIndexBefore(index, leftChildIndex, rightChildIndex);\n  }\n\n  /**\n   * @public\n   * @override\n   * inserts a node into the heap and rebase leaf node to min key\n   * @param {number|string} key\n   * @param {object} value\n   */\n  insert(key, value) {\n    const newNode = super.insert(key, value);\n    if (this._leaf === null || key < this._leaf.getKey()) {\n      this._leaf = newNode;\n    }\n    return newNode;\n  }\n\n  /**\n   * @public\n   * returns a shallow copy of a max heap\n   * @returns {MaxHeap}\n   */\n  clone() {\n    return super._clone(MaxHeap);\n  }\n\n  /**\n   * @public\n   * @static\n   * builds a max heap from an array of items\n   * @param {array} items\n   * @returns {MaxHeap}\n   */\n  static heapify(items) {\n    return super._heapify(items, MaxHeap);\n  }\n}\n\nmodule.exports = MaxHeap;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/heap/src/maxHeap.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/heap/src/minHeap.js":
/*!*************************************************************!*\
  !*** ./node_modules/@datastructures-js/heap/src/minHeap.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * datastructures-js/heap\n * @copyright 2019 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst Heap = __webpack_require__(/*! ./heap */ \"./node_modules/@datastructures-js/heap/src/heap.js\");\n\n/**\n * @class MinHeap\n * @extends Heap\n */\nclass MinHeap extends Heap {\n  /**\n   * @private\n   * gets the min child's index of two node's children\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _getMinChildIndex(leftChildIndex, rightChildIndex) {\n    const leftChild = this._nodes[leftChildIndex];\n    const rightChild = this._nodes[rightChildIndex];\n    if (leftChild.getKey() < rightChild.getKey()) {\n      return leftChildIndex;\n    }\n    return rightChildIndex;\n  }\n\n  /**\n   * @private\n   * returns the min child's index of two children before an index\n   * @param {number} index\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _getMinChildIndexBefore(index, leftChildIndex, rightChildIndex) {\n    const leftChild = this._nodes[leftChildIndex];\n    const rightChild = this._nodes[rightChildIndex];\n    if (rightChild.getKey() < leftChild.getKey() && rightChildIndex < index) {\n      return rightChildIndex;\n    }\n    return leftChildIndex;\n  }\n\n  /**\n   * @protected\n   * checks if child's key is smaller than its parent's key\n   * @returns {boolean}\n   */\n  _shouldSwap(childIndex, parentIndex) {\n    if (childIndex < 0 || childIndex >= this.size()) return false;\n    if (parentIndex < 0 || parentIndex >= this.size()) return false;\n\n    const child = this._nodes[childIndex];\n    const parent = this._nodes[parentIndex];\n\n    return child.getKey() < parent.getKey();\n  }\n\n  /**\n   * @protected\n   * @override\n   * implements the parent's function to select a child's index\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _compareChildren(leftChildIndex, rightChildIndex) {\n    return this._getMinChildIndex(leftChildIndex, rightChildIndex);\n  }\n\n  /**\n   * @protected\n   * @override\n   * implements the parent's function to select a child's index before an index\n   * @param {number} index\n   * @param {number} leftChildIndex\n   * @param {number} rightChildIndex\n   * @returns {number}\n   */\n  _compareChildrenBefore(index, leftChildIndex, rightChildIndex) {\n    return this._getMinChildIndexBefore(index, leftChildIndex, rightChildIndex);\n  }\n\n  /**\n   * @public\n   * @override\n   * inserts a node into the heap and rebase leaf node to max key\n   * @param {number|string} key\n   * @param {object} value\n   */\n  insert(key, value) {\n    const newNode = super.insert(key, value);\n    if (this._leaf === null || key > this._leaf.getKey()) {\n      this._leaf = newNode;\n    }\n    return newNode;\n  }\n\n  /**\n   * @public\n   * returns a shallow copy of a min heap\n   * @returns {MinHeap}\n   */\n  clone() {\n    return super._clone(MinHeap);\n  }\n\n  /**\n   * @public\n   * builds a min heap from an array of items\n   * @param {array} items\n   * @returns {MinHeap}\n   */\n  static heapify(items) {\n    return super._heapify(items, MinHeap);\n  }\n}\n\nmodule.exports = MinHeap;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/heap/src/minHeap.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/linked-list/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@datastructures-js/linked-list/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const LinkedList = __webpack_require__(/*! ./src/linkedList */ \"./node_modules/@datastructures-js/linked-list/src/linkedList.js\");\nconst DoublyLinkedList = __webpack_require__(/*! ./src/doublyLinkedList */ \"./node_modules/@datastructures-js/linked-list/src/doublyLinkedList.js\");\n\nmodule.exports = { LinkedList, DoublyLinkedList };\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/linked-list/index.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/linked-list/src/doublyLinkedList.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@datastructures-js/linked-list/src/doublyLinkedList.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * datastructures-js/linked-list\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst DoublyLinkedListNode = __webpack_require__(/*! ./doublyLinkedListNode */ \"./node_modules/@datastructures-js/linked-list/src/doublyLinkedListNode.js\");\n\n/**\n * @class DoublyLinkedList\n */\nclass DoublyLinkedList {\n  constructor() {\n    this._head = null;\n    this._tail = null;\n    this._count = 0;\n  }\n\n  /**\n   * @public\n   * adds a node at the beginning of the linked list\n   * @param {object} value\n   * @returns {DoublyLinkedListNode}\n   */\n  insertFirst(value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (this.isEmpty()) {\n      this._head = newNode;\n      this._tail = newNode;\n    } else {\n      this._head.setPrev(newNode);\n      newNode.setNext(this._head);\n      this._head = newNode;\n    }\n    this._count += 1;\n    return this._head;\n  }\n\n  /**\n   * @public\n   * adds a node at the end of the linked list\n   * @param {object} value\n   * @returns {DoublyLinkedListNode}\n   */\n  insertLast(value) {\n    const newNode = new DoublyLinkedListNode(value);\n    if (this.isEmpty()) {\n      this._head = newNode;\n      this._tail = newNode;\n    } else {\n      newNode.setPrev(this._tail);\n      this._tail.setNext(newNode);\n      this._tail = newNode;\n    }\n    this._count += 1;\n    return this._tail;\n  }\n\n  /**\n   * @public\n   * adds a node at a specific position\n   * @param {object} value\n   * @param {number} position\n   * @returns {DoublyLinkedListNode}\n   */\n  insertAt(value, position = 0) {\n    if (Number.isNaN(+position)\n      || position < 0 || position > this._count) return null;\n\n    if (position === 0) {\n      return this.insertFirst(value);\n    }\n\n    if (position === this._count) {\n      return this.insertLast(value);\n    }\n\n    let counter = 1;\n    let prev = this._head;\n    while (counter < position) {\n      counter += 1;\n      prev = prev.getNext();\n    }\n\n    const newNode = new DoublyLinkedListNode(value);\n    newNode.setNext(prev.getNext());\n    newNode.setPrev(prev);\n    newNode.getNext().setPrev(newNode);\n    newNode.getPrev().setNext(newNode);\n    this._count += 1;\n    return newNode;\n  }\n\n  /**\n   * @public\n   * removes the head node\n   * @returns {boolean}\n   */\n  removeFirst() {\n    if (this._head === null) return false;\n\n    this._head = this._head.getNext();\n    this._head.setPrev(null);\n    this._count -= 1;\n    return true;\n  }\n\n  /**\n   * @public\n   * removes last node in the linked list\n   * @returns {boolean}\n   */\n  removeLast() {\n    if (this._head === null) return false;\n\n    if (this._head.getNext() === null) {\n      this._head = null;\n      this._tail = null;\n      this._count -= 1;\n      return true;\n    }\n\n    this._tail = this._tail.getPrev();\n    this._tail.setNext(null);\n    this._count -= 1;\n    return true;\n  }\n\n  /**\n   * @public\n   * removes a node in a specific position\n   * @param {number} position\n   * @returns {boolean}\n   */\n  removeAt(position) {\n    if (Number.isNaN(+position)\n      || position < 0\n      || position >= this._count) return false;\n\n    if (position === 0) {\n      return this.removeFirst();\n    }\n\n    if (position === this._count - 1) {\n      return this.removeLast();\n    }\n\n    let counter = 1;\n    let prev = this._head;\n    while (counter < position) {\n      counter += 1;\n      prev = prev.getNext();\n    }\n\n    prev.setNext(prev.getNext().getNext());\n    prev.getNext().setPrev(prev);\n    this._count -= 1;\n    return true;\n  }\n\n  /**\n   * @public\n   * removes all nodes based on a callback\n   * @param {function} cb\n   * @returns {number} count of removed nodes\n   * @throws {Error} if cb is not a function\n   */\n  removeEach(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.removeEach(cb) expects a callback');\n    }\n\n    let removed = 0;\n    let prev = null;\n    let node = this._head;\n\n    while (node !== null) {\n      if (cb(node)) {\n        if (prev === null) {\n          this.removeFirst();\n        } else if (prev.getNext() === null) {\n          this.removeLast();\n        } else {\n          prev.setNext(prev.getNext().getNext());\n          if (prev.getNext() !== null) {\n            prev.getNext().setPrev(prev);\n          }\n          this._count -= 1;\n        }\n        removed += 1;\n      }\n      prev = node;\n      node = node.getNext();\n    }\n\n    return removed;\n  }\n\n  /**\n   * @public\n   * traverse the list from beginning to end\n   * @param {function} cb\n   * @param {DoublyLinkedListNode} current\n   */\n  forEach(cb, current = this._head) {\n    if (typeof cb !== 'function') {\n      throw new Error('.forEach(cb) expects a callback');\n    }\n\n    if (current === null) return;\n\n    cb(current);\n    this.forEach(cb, current.getNext());\n  }\n\n  /**\n   * @public\n   * traverse the list from end to beginning\n   * @param {function} cb\n   * @param {DoublyLinkedListNode} current\n   */\n  forEachReverse(cb, current = this._tail) {\n    if (typeof cb !== 'function') {\n      throw new Error('.forEachReverse(cb) expects a callback');\n    }\n\n    if (current === null) return;\n\n    cb(current);\n    this.forEachReverse(cb, current.getPrev());\n  }\n\n  /**\n   * @public\n   * finds a node in the linked list using on a callback\n   * @param {function} cb\n   * @param {DoublyLinkedListNode} current\n   * @returns {DoublyLinkedListNode}\n   * @throws {Error} if cb is not a function\n   */\n  find(cb, current = this._head) {\n    if (typeof cb !== 'function') {\n      throw new Error('.find(cb) expects a callback');\n    }\n\n    // did not find the node\n    if (current === null) return null;\n\n    // found the node\n    if (cb(current)) return current;\n\n    // haven't found the node, check next\n    return this.find(cb, current.getNext());\n  }\n\n  /**\n   * @public\n   * filters the linked list based on a callback\n   * @param {function} cb\n   * @returns {LinkedList}\n   * @throws {Error} if cb is not a function\n   */\n  filter(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.filter(cb) expects a callback');\n    }\n\n    const result = new DoublyLinkedList();\n    let last = null;\n    this.forEach((node) => {\n      if (!cb(node)) return;\n      last = result.insertLast(node.getValue(), last);\n    });\n\n    return result;\n  }\n\n  /**\n   * @public\n   * @returns {DoublyLinkedListNode}\n   */\n  head() {\n    return this._head;\n  }\n\n  /**\n   * @public\n   * @returns {DoublyLinkedListNode}\n   */\n  tail() {\n    return this._tail;\n  }\n\n  /**\n   * @public\n   * @returns {number}\n   */\n  count() {\n    return this._count;\n  }\n\n  /**\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    const result = [];\n    this.forEach((node) => result.push(node.getValue()));\n    return result;\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._head === null;\n  }\n\n  /**\n   * @public\n   * clears the linked list\n   */\n  clear() {\n    this._head = null;\n    this._tail = null;\n    this._count = 0;\n  }\n}\n\nmodule.exports = DoublyLinkedList;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/linked-list/src/doublyLinkedList.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/linked-list/src/doublyLinkedListNode.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@datastructures-js/linked-list/src/doublyLinkedListNode.js ***!
  \*********************************************************************************/
/***/ ((module) => {

eval("/**\n * @datastructures-js/linked-list\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\n/**\n * @class DoublyLinkedListNode\n */\nclass DoublyLinkedListNode {\n  /**\n   * @constructor\n   * @param {object} value\n   * @param {DoublyLinkedListNode} prev\n   * @param {DoublyLinkedListNode} next\n   */\n  constructor(value, prev, next) {\n    this._value = value;\n    this._prev = prev || null;\n    this._next = next || null;\n  }\n\n  /**\n   * @public\n   * @param {object} value\n   */\n  setValue(value) {\n    this._value = value;\n  }\n\n  /**\n   * @public\n   * @returns {object}\n   */\n  getValue() {\n    return this._value;\n  }\n\n  /**\n   * @public\n   * @param {DoublyLinkedListNode}\n   */\n  setNext(next) {\n    this._next = next || null;\n  }\n\n  /**\n   * @public\n   * @returns {DoublyLinkedListNode}\n   */\n  getNext() {\n    return this._next;\n  }\n\n  /**\n   * @public\n   * @param {DoublyLinkedListNode} prev\n   */\n  setPrev(prev) {\n    this._prev = prev || null;\n  }\n\n  /**\n   * @public\n   * @returns {DoublyLinkedListNode}\n   */\n  getPrev() {\n    return this._prev;\n  }\n}\n\nmodule.exports = DoublyLinkedListNode;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/linked-list/src/doublyLinkedListNode.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/linked-list/src/linkedList.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@datastructures-js/linked-list/src/linkedList.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * datastructures-js/linked-list\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst LinkedListNode = __webpack_require__(/*! ./linkedListNode */ \"./node_modules/@datastructures-js/linked-list/src/linkedListNode.js\");\n\n/**\n * @class LinkedList\n */\nclass LinkedList {\n  constructor() {\n    this._head = null;\n    this._count = 0;\n  }\n\n  /**\n   * @public\n   * adds a node at the beginning of the linked list\n   * @param {object} value\n   * @returns {boolean}\n   */\n  insertFirst(value) {\n    this._head = new LinkedListNode(value, this._head);\n    this._count += 1;\n    return this._head;\n  }\n\n  /**\n   * @public\n   * adds a node at the end of the linked list\n   * @param {object} value\n   * @param {LinkedListNode} current - the starting node\n   * @returns {boolean}\n   */\n  insertLast(value, current = this._head) {\n    if (this.isEmpty()) {\n      return this.insertFirst(value);\n    }\n\n    // not the last node, move to next\n    if (current.getNext() instanceof LinkedListNode) {\n      return this.insertLast(value, current.getNext());\n    }\n\n    // arrived to last node, add new node after\n    current.setNext(new LinkedListNode(value));\n    this._count += 1;\n    return current.getNext();\n  }\n\n  /**\n   * @public\n   * adds a node at a specific position\n   * @param {object} value\n   * @param {number} position\n   * @returns {boolean}\n   */\n  insertAt(value, position = 0) {\n    if (Number.isNaN(+position)\n      || position < 0 || position > this._count) return null;\n\n    // head node is at position 0\n    if (position === 0) {\n      return this.insertFirst(value);\n    }\n\n    let counter = 1;\n    let prev = this._head;\n    while (counter < position) {\n      counter += 1;\n      prev = prev.getNext();\n    }\n\n    // add it at a position after the head, between prev & prev.getNext()\n    prev.setNext(new LinkedListNode(value, prev.getNext()));\n    this._count += 1;\n    return prev.getNext();\n  }\n\n  /**\n   * @public\n   * removes the head node\n   * @returns {boolean}\n   */\n  removeFirst() {\n    if (this.isEmpty()) return false;\n\n    this._head = this._head.getNext();\n    this._count -= 1;\n    return true;\n  }\n\n  /**\n   * @public\n   * removes last node in the linked list\n   * @param {LinkedListNode} prev - default is null\n   * @param {LinkedListNode} current - default is head\n   * @returns {boolean}\n   */\n  removeLast(prev = null, current = this._head) {\n    if (this.isEmpty()) return false;\n\n    // not last node, move next\n    if (current.getNext() instanceof LinkedListNode) {\n      return this.removeLast(current, current.getNext());\n    }\n\n    // linked list has 1 node\n    if (prev === null) {\n      return this.removeFirst();\n    }\n\n    // arrived to last node, remove it\n    prev.setNext(null);\n    this._count -= 1;\n    return true;\n  }\n\n  /**\n   * @public\n   * removes all nodes based on a callback condition\n   * @param {function} cb\n   * @returns {number} count of removed nodes\n   * @throws {Error} if cb is not a function\n   */\n  removeEach(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.removeEach(cb) expects a callback');\n    }\n\n    let removed = 0;\n    let prev = null;\n    let current = this._head;\n\n    while (current instanceof LinkedListNode) {\n      if (cb(current)) {\n        if (prev === null) {\n          this.removeFirst();\n        } else {\n          prev.setNext(prev.getNext().getNext());\n          this._count -= 1;\n        }\n        removed += 1;\n      }\n      prev = current;\n      current = current.getNext();\n    }\n\n    return removed;\n  }\n\n  /**\n   * @public\n   * removes a node in a specific position\n   * @param {number} position\n   * @returns {boolean}\n   */\n  removeAt(position) {\n    if (Number.isNaN(+position)\n      || position < 0\n      || position >= this._count) return false;\n\n    if (position === 0) {\n      return this.removeFirst();\n    }\n\n    let counter = 1;\n    let prev = this._head;\n    while (counter < position) {\n      counter += 1;\n      prev = prev.getNext();\n    }\n\n    prev.setNext(prev.getNext().getNext());\n    this._count -= 1;\n    return true;\n  }\n\n  /**\n   * @public\n   * traverse the linkedlist from beginning to end\n   * @param {function} cb\n   * @param {LinkedListNode} current\n   * @throws {Error} if cb is not a function\n   */\n  forEach(cb, current = this._head) {\n    if (typeof cb !== 'function') {\n      throw new Error('.forEach(cb) expects a callback');\n    }\n\n    if (current === null) return;\n\n    cb(current);\n    this.forEach(cb, current.getNext());\n  }\n\n  /**\n   * @public\n   * finds a node in the linked list based on a callback condition\n   * @param {function} cb\n   * @returns {LinkedListNode} current\n   * @throws {Error} if cb is not a function\n   */\n  find(cb, current = this._head) {\n    if (typeof cb !== 'function') {\n      throw new Error('.find(cb) expects a callback');\n    }\n\n    // did not find the node\n    if (current === null) return null;\n\n    // found the node\n    if (cb(current)) return current;\n\n    // haven't found the node, check next\n    return this.find(cb, current.getNext());\n  }\n\n  /**\n   * @public\n   * filters the linked list based on a callback condition\n   * @param {function} cb\n   * @returns {LinkedList}\n   * @throws {Error} if cb is not a function\n   */\n  filter(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.filter(cb) expects a callback');\n    }\n\n    const result = new LinkedList();\n    let last = null;\n    this.forEach((node) => {\n      if (!cb(node)) return;\n      last = result.insertLast(node.getValue(), last);\n    });\n\n    return result;\n  }\n\n  /**\n   * @public\n   * @returns {LinkedListNode}\n   */\n  head() {\n    return this._head;\n  }\n\n  /**\n   * @public\n   * @returns {number}\n   */\n  count() {\n    return this._count;\n  }\n\n  /**\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    const result = [];\n    this.forEach((node) => result.push(node.getValue()));\n    return result;\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._head === null;\n  }\n\n  /**\n   * @public\n   * clears the linked list\n   */\n  clear() {\n    this._head = null;\n    this._count = 0;\n  }\n}\n\nmodule.exports = LinkedList;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/linked-list/src/linkedList.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/linked-list/src/linkedListNode.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@datastructures-js/linked-list/src/linkedListNode.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("/**\n * @datastructures-js/linked-list\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\n/**\n * @class LinkedListNode\n */\nclass LinkedListNode {\n  /**\n   * @constructor\n   * @param {object} value\n   * @param {LinkedListNode} next\n   */\n  constructor(value, next) {\n    this._value = value;\n    this._next = next || null;\n  }\n\n  /**\n   * @public\n   * @param {object} value\n   */\n  setValue(value) {\n    this._value = value;\n  }\n\n  /**\n   * @public\n   * @returns {object}\n   */\n  getValue() {\n    return this._value;\n  }\n\n  /**\n   * @public\n   * @param {LinkedListNode}\n   */\n  setNext(next) {\n    this._next = next || null;\n  }\n\n  /**\n   * @public\n   * @returns {LinkedListNode}\n   */\n  getNext() {\n    return this._next;\n  }\n}\n\nmodule.exports = LinkedListNode;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/linked-list/src/linkedListNode.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/priority-queue/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@datastructures-js/priority-queue/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const MinPriorityQueue = __webpack_require__(/*! ./src/minPriorityQueue */ \"./node_modules/@datastructures-js/priority-queue/src/minPriorityQueue.js\");\nconst MaxPriorityQueue = __webpack_require__(/*! ./src/maxPriorityQueue */ \"./node_modules/@datastructures-js/priority-queue/src/maxPriorityQueue.js\");\n\nmodule.exports = { MinPriorityQueue, MaxPriorityQueue };\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/priority-queue/index.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/priority-queue/src/maxPriorityQueue.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@datastructures-js/priority-queue/src/maxPriorityQueue.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @datastructures-js/priority-queue\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst { MaxHeap } = __webpack_require__(/*! @datastructures-js/heap */ \"./node_modules/@datastructures-js/heap/index.js\");\nconst PriorityQueue = __webpack_require__(/*! ./priorityQueue */ \"./node_modules/@datastructures-js/priority-queue/src/priorityQueue.js\");\n\n/**\n * @class MaxPriorityQueue\n * @extends PriorityQueue\n */\nclass MaxPriorityQueue extends PriorityQueue {\n  constructor(options) {\n    super(options);\n    this._heap = new MaxHeap();\n  }\n}\n\nmodule.exports = MaxPriorityQueue;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/priority-queue/src/maxPriorityQueue.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/priority-queue/src/minPriorityQueue.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@datastructures-js/priority-queue/src/minPriorityQueue.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @datastructures-js/priority-queue\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst { MinHeap } = __webpack_require__(/*! @datastructures-js/heap */ \"./node_modules/@datastructures-js/heap/index.js\");\nconst PriorityQueue = __webpack_require__(/*! ./priorityQueue */ \"./node_modules/@datastructures-js/priority-queue/src/priorityQueue.js\");\n\n/**\n * @class MinPriorityQueue\n * @extends PriorityQueue\n */\nclass MinPriorityQueue extends PriorityQueue {\n  constructor(options) {\n    super(options);\n    this._heap = new MinHeap();\n  }\n}\n\nmodule.exports = MinPriorityQueue;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/priority-queue/src/minPriorityQueue.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/priority-queue/src/priorityQueue.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@datastructures-js/priority-queue/src/priorityQueue.js ***!
  \*****************************************************************************/
/***/ ((module) => {

eval("/**\n * @datastructures-js/priority-queue\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\n/**\n * @abstract\n * @class PriorityQueue\n */\nclass PriorityQueue {\n  constructor(options = {}) {\n    const { priority } = options;\n    if (priority !== undefined && typeof priority !== 'function') {\n      throw new Error('invalid priority callback');\n    }\n    this._getPriority = typeof priority === 'function' ? priority : null;\n  }\n\n  /**\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._heap.size();\n  }\n\n  /**\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._heap.isEmpty();\n  }\n\n  /**\n   * @public\n   * returns the element with highest priority in the queue\n   * @returns {object}\n   */\n  front() {\n    if (this.isEmpty()) return null;\n\n    const first = this._heap.root();\n    return {\n      priority: first.getKey(),\n      element: first.getValue()\n    };\n  }\n\n  /**\n   * @public\n   * returns the element with lowest priority in the queue\n   * @returns {object}\n   */\n  back() {\n    if (this.isEmpty()) return null;\n\n    const last = this._heap.leaf();\n    return {\n      priority: last.getKey(),\n      element: last.getValue()\n    };\n  }\n\n  /**\n   * @public\n   * add an element to the queue based on its priority\n   * @param {object} element\n   * @param {number} p - priority\n   * @throws {Error} if priority is not a valid number\n   */\n  enqueue(element, p) {\n    if (p && Number.isNaN(+p)) {\n      throw new Error('invalid priority number');\n    }\n\n    if (Number.isNaN(+p) && this._getPriority === null) {\n      throw new Error('missing priority number or constructor callback');\n    }\n\n    const priority = !Number.isNaN(+p) ? p : this._getPriority(element);\n    this._heap.insert(priority, element);\n  }\n\n  /**\n   * @public\n   * removes and returns the element with highest priority in the queue\n   * @returns {object}\n   */\n  dequeue() {\n    if (this.isEmpty()) return null;\n\n    const first = this._heap.extractRoot();\n    return {\n      priority: first.getKey(),\n      element: first.getValue()\n    };\n  }\n\n  /**\n   * @public\n   * returns an sorted list of elements from highest priority to lowest\n   * @returns {array}\n   */\n  toArray() {\n    return this._heap\n      .clone()\n      .sort()\n      .map((n) => ({ priority: n.getKey(), element: n.getValue() }))\n      .reverse();\n  }\n\n  /**\n   * @public\n   * clears the queue\n   */\n  clear() {\n    this._heap.clear();\n  }\n}\n\nmodule.exports = PriorityQueue;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/priority-queue/src/priorityQueue.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/queue/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@datastructures-js/queue/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Queue = __webpack_require__(/*! ./src/queue */ \"./node_modules/@datastructures-js/queue/src/queue.js\");\n\nmodule.exports = Queue;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/queue/index.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/queue/src/queue.js":
/*!************************************************************!*\
  !*** ./node_modules/@datastructures-js/queue/src/queue.js ***!
  \************************************************************/
/***/ ((module) => {

eval("/**\n * @license MIT\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n *\n * @class\n */\nclass Queue {\n  /**\n   * Creates a queue.\n   * @param {array} [elements]\n   */\n  constructor(elements) {\n    this._elements = Array.isArray(elements) ? elements : [];\n    this._offset = 0;\n  }\n\n  /**\n   * Adds an element at the back of the queue.\n   * @public\n   * @param {any} element\n   */\n  enqueue(element) {\n    this._elements.push(element);\n  }\n\n  /**\n   * Dequeues the front element in the queue.\n   * @public\n   * @returns {any}\n   */\n  dequeue() {\n    if (this.size() === 0) return null;\n\n    const first = this.front();\n    this._offset += 1;\n\n    if (this._offset * 2 < this._elements.length) return first;\n\n    // only remove dequeued elements when reaching half size\n    // to decrease latency of shifting elements.\n    this._elements = this._elements.slice(this._offset);\n    this._offset = 0;\n    return first;\n  }\n\n  /**\n   * Returns the front element of the queue.\n   * @public\n   * @returns {any}\n   */\n  front() {\n    return this.size() > 0 ? this._elements[this._offset] : null;\n  }\n\n  /**\n   * Returns the back element of the queue.\n   * @public\n   * @returns {any}\n   */\n  back() {\n    return this.size() > 0 ? this._elements[this._elements.length - 1] : null;\n  }\n\n  /**\n   * Returns the number of elements in the queue.\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._elements.length - this._offset;\n  }\n\n  /**\n   * Checks if the queue is empty.\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this.size() === 0;\n  }\n\n  /**\n   * Returns the remaining elements in the queue as an array.\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    return this._elements.slice(this._offset);\n  }\n\n  /**\n   * Clears the queue.\n   * @public\n   */\n  clear() {\n    this._elements = [];\n    this._offset = 0;\n  }\n\n  /**\n   * Creates a shallow copy of the queue.\n   * @public\n   * @return {Queue}\n   */\n  clone() {\n    return new Queue(this._elements.slice(this._offset));\n  }\n\n  /**\n   * Creates a queue from an existing array.\n   * @public\n   * @static\n   * @param {array} elements\n   * @return {Queue}\n   */\n  static fromArray(elements) {\n    return new Queue(elements);\n  }\n}\n\nmodule.exports = Queue;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/queue/src/queue.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/set/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@datastructures-js/set/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const EnhancedSet = __webpack_require__(/*! ./src/enhancedSet */ \"./node_modules/@datastructures-js/set/src/enhancedSet.js\");\n\nmodule.exports = EnhancedSet;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/set/index.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/set/src/enhancedSet.js":
/*!****************************************************************!*\
  !*** ./node_modules/@datastructures-js/set/src/enhancedSet.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("/**\n * @datastructures-js/set\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\n/**\n * @class EnhancedSet\n * @extends Set - ES6 Set REF: https://mzl.la/2QajnHr\n * implements main set operations\n */\nclass EnhancedSet extends Set {\n  /**\n   * @public\n   * Union: https://en.wikipedia.org/wiki/Union_(set_theory)\n   * returns a set of all elements of the set and another set\n   * @param {Set} set\n   * @returns {EnhancedSet}\n   * @throws {Error}\n   */\n  union(set) {\n    if (!(set instanceof Set)) {\n      throw new Error('.union expects a Set');\n    }\n\n    const result = new EnhancedSet();\n    this.forEach((element) => result.add(element));\n    set.forEach((element) => result.add(element));\n    return result;\n  }\n\n  /**\n   * @public\n   * Intersection: https://en.wikipedia.org/wiki/Intersection_(set_theory)\n   * returns the common elements between the set and another set\n   * @param {Set} set\n   * @returns {EnhancedSet}\n   * @throws {Error}\n   */\n  intersect(set) {\n    if (!(set instanceof Set)) {\n      throw new Error('.intersect expects a Set');\n    }\n\n    const result = new EnhancedSet();\n    this.forEach((element) => {\n      if (set.has(element)) {\n        result.add(element);\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * @public\n   * Complement: https://en.wikipedia.org/wiki/Complement_(set_theory)\n   * returns the elements in the set that are not in another set\n   * @param {Set} set\n   * @returns {EnhancedSet}\n   */\n  complement(set) {\n    if (!(set instanceof Set)) {\n      throw new Error('.complement expects a Set');\n    }\n\n    const result = new EnhancedSet();\n    this.forEach((element) => {\n      if (!set.has(element)) {\n        result.add(element);\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * @public\n   * Subset: https://en.wikipedia.org/wiki/Subset\n   * checks if the set is a subset of another set\n   * @param {Set} set\n   * @returns {boolean}\n   */\n  isSubsetOf(set) {\n    if (!(set instanceof Set)) return false;\n\n    let count = 0;\n    this.forEach((element) => {\n      if (set.has(element)) {\n        count += 1;\n      }\n    });\n\n    return count === this.size;\n  }\n\n  /**\n   * @public\n   * Subset: https://en.wikipedia.org/wiki/Subset\n   * checks if the set is a superset of another set\n   * @param {Set} set\n   * @returns {boolean}\n   */\n  isSupersetOf(set) {\n    if (!(set instanceof Set)) return false;\n\n    let count = 0;\n    set.forEach((element) => {\n      if (this.has(element)) {\n        count += 1;\n      }\n    });\n\n    return count === set.size;\n  }\n\n  /**\n   * @public\n   * Cartesian Product: https://en.wikipedia.org/wiki/Cartesian_product\n   * @param {Set} set\n   * @param {string} separator\n   * @returns {EnhancedSet}\n   */\n  product(set, seprator = '') {\n    if (!(set instanceof Set)) {\n      throw new Error('.product expects a Set');\n    }\n\n    const result = new EnhancedSet();\n    this.forEach((e1) => {\n      set.forEach((e2) => {\n        result.add(`${e1}${seprator}${e2}`);\n      });\n    });\n\n    return result;\n  }\n\n  /**\n   * @public\n   * projecting the power concept into Set self Cartesian Product\n   * @param {number} m\n   * @param {string} separator\n   * @returns {EnhancedSet}\n   */\n  power(m, seprator = '') {\n    if (Number.isNaN(+m) || +m < 0) {\n      throw new Error('.power expects a positive number');\n    }\n\n    if (+m === 0) return new EnhancedSet();\n\n    let result = this.clone();\n    for (let i = 0; i < +m - 1; i += 1) {\n      result = result.product(this, seprator);\n    }\n\n    return result;\n  }\n\n  /**\n   * @public\n   * finds m permutations of the set\n   * @param {number} m\n   * @param {string} separator\n   * @returns {EnhancedSet}\n   */\n  permutations(m, separator = '') {\n    if (Number.isNaN(+m) || +m < 0) {\n      throw new Error('.permutations expects a positive number');\n    }\n\n    if (m > this.size) {\n      throw new Error('.permutations expects a number less or euqal set size');\n    }\n\n    const result = new EnhancedSet();\n\n    const generatePermutation = (currentSet, i = 0, prefix = '') => {\n      if (i === m && prefix.length > 0) {\n        result.add(prefix);\n        return;\n      }\n\n      currentSet.forEach((el) => {\n        const nextSet = currentSet.clone();\n        nextSet.delete(el);\n        const acc = prefix.length ? `${prefix}${separator}${el}` : `${el}`;\n        generatePermutation(nextSet, i + 1, acc);\n      });\n    };\n\n    generatePermutation(this.clone());\n    return result;\n  }\n\n  /**\n   * @public\n   * checks if two sets are equal\n   * @param {Set} set\n   * @returns {boolean}\n   */\n  equals(set) {\n    if (!(set instanceof Set)) {\n      throw new Error('.equals expects a Set');\n    }\n\n    return this.isSubsetOf(set) && this.size === set.size;\n  }\n\n  /**\n   * @public\n   * filters the set elements using a callback\n   * @param {function} cb\n   * @returns {EnhancedSet}\n   */\n  filter(cb) {\n    if (typeof cb !== 'function') {\n      throw new Error('.filter expects a callback');\n    }\n\n    const result = new EnhancedSet();\n    this.forEach((element) => {\n      if (cb(element)) {\n        result.add(element);\n      }\n    });\n\n    return result;\n  }\n\n  /**\n   * @public\n   * converst the set into an array\n   * @returns {array}\n   */\n  toArray() {\n    return Array.from(this);\n  }\n\n  /**\n   * @public\n   * clones the set\n   * @returns {EnhancedSet}\n   */\n  clone() {\n    return new EnhancedSet(this.toArray());\n  }\n}\n\nmodule.exports = EnhancedSet;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/set/src/enhancedSet.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/stack/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@datastructures-js/stack/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Stack = __webpack_require__(/*! ./src/stack */ \"./node_modules/@datastructures-js/stack/src/stack.js\");\n\nmodule.exports = Stack;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/stack/index.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/stack/src/stack.js":
/*!************************************************************!*\
  !*** ./node_modules/@datastructures-js/stack/src/stack.js ***!
  \************************************************************/
/***/ ((module) => {

eval("/**\n * @license MIT\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n *\n * @class\n */\nclass Stack {\n  /**\n   * Creates a stack.\n   * @param {array} [elements]\n   */\n  constructor(elements) {\n    this._elements = Array.isArray(elements) ? elements : [];\n  }\n\n  /**\n   * Checks if the stack is empty.\n   * @public\n   * @returns {boolean}\n   */\n  isEmpty() {\n    return this._elements.length === 0;\n  }\n\n  /**\n   * Returns the number of elements in the stack.\n   * @public\n   * @returns {number}\n   */\n  size() {\n    return this._elements.length;\n  }\n\n  /**\n   * Returns the top element in the stack.\n   * @public\n   * @returns {object}\n   */\n  peek() {\n    if (this.isEmpty()) return null;\n\n    return this._elements[this._elements.length - 1];\n  }\n\n  /**\n   * Adds an element to the top of the stack.\n   * @public\n   * @param {object} element\n   */\n  push(element) {\n    this._elements.push(element);\n  }\n\n  /**\n   * Removes and returns the top element in the stack.\n   * @public\n   * @returns {object}\n   */\n  pop() {\n    if (this.isEmpty()) return null;\n\n    return this._elements.pop();\n  }\n\n  /**\n   * Returns the remaining elements as an array.\n   * @public\n   * @returns {array}\n   */\n  toArray() {\n    return this._elements.slice();\n  }\n\n  /**\n   * Clears all elements from the stack.\n   * @public\n   */\n  clear() {\n    this._elements = [];\n  }\n\n  /**\n   * Creates a shallow copy from the stack.\n   * @public\n   * @return {Stack}\n   */\n  clone() {\n    return new Stack(this._elements.slice());\n  }\n\n  /**\n   * Creates a stack from an existing array\n   * @public\n   * @static\n   * @param {array} [elements]\n   * @return {Stack}\n   */\n  static fromArray(elements) {\n    return new Stack(elements);\n  }\n}\n\nmodule.exports = Stack;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/stack/src/stack.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/trie/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@datastructures-js/trie/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Trie = __webpack_require__(/*! ./src/trie */ \"./node_modules/@datastructures-js/trie/src/trie.js\");\n\nmodule.exports = Trie;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/trie/index.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/trie/src/trie.js":
/*!**********************************************************!*\
  !*** ./node_modules/@datastructures-js/trie/src/trie.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @datastructures-js/trie\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\nconst TrieNode = __webpack_require__(/*! ./trieNode */ \"./node_modules/@datastructures-js/trie/src/trieNode.js\");\n\n/**\n * @class Trie\n */\nclass Trie {\n  constructor() {\n    this._root = new TrieNode('');\n    this._wordsCount = 0;\n    this._nodesCount = 1; // root node\n  }\n\n  /**\n   * @public\n   * inserts a word into the trie and returns its last char node\n   * @param {string} word\n   * @param {TrieNode} node\n   * @param {number} i\n   * @returns {TrieNode}\n   */\n  insert(word, node = this._root, i = 0) {\n    if (typeof word !== 'string') {\n      throw new Error('Trie.insert expects a string word');\n    }\n\n    if (i === word.length) {\n      if (!node.isEndOfWord()) {\n        node.setEndOfWord(true);\n        this._wordsCount += 1;\n      }\n      return node;\n    }\n\n    if (!node.hasChild(word[i])) {\n      node.addChild(word[i]);\n      this._nodesCount += 1;\n    }\n\n    return this.insert(word, node.getChild(word[i]), i + 1);\n  }\n\n  /**\n   * @public\n   * checks if a word exists in the trie\n   * @param {string} word\n   * @param {TrieNode} node\n   * @param {number} i\n   * @returns {boolean}\n   */\n  has(word, node = this._root, i = 0) {\n    if (typeof word !== 'string') return false;\n\n    if (i === word.length) {\n      return node.isEndOfWord();\n    }\n\n    if (!node.hasChild(word[i])) return false;\n\n    return this.has(word, node.getChild(word[i]), i + 1);\n  }\n\n  /**\n   * @public\n   * finds a word in the trie and returns its last char node\n   * @param {string} word\n   * @param {TrieNode} node\n   * @param {number} i\n   * @returns {TrieNode}\n   */\n  find(word, node = this._root, i = 0) {\n    if (typeof word !== 'string') return null;\n\n    if (i === word.length) {\n      return node.isEndOfWord() ? node : null;\n    }\n\n    if (!node.hasChild(word[i])) return null;\n\n    return this.find(word, node.getChild(word[i]), i + 1);\n  }\n\n  /**\n   * @public\n   * removes a word from the trie\n   * @param {string} word\n   * @returns {boolean}\n   */\n  remove(word) {\n    const lastCharNode = this.find(word);\n\n    if (lastCharNode === null) return false;\n\n    if (lastCharNode.childrenCount() > 0 || word === '') {\n      lastCharNode.setEndOfWord(false);\n      this._wordsCount -= 1;\n      return true;\n    }\n\n    let current = lastCharNode;\n    while (current.getChar() !== '') {\n      if (current.childrenCount() === 0) {\n        current.getParent().removeChild(current.getChar());\n        this._nodesCount -= 1;\n      }\n      current = current.getParent();\n    }\n\n    this._wordsCount -= 1;\n    return true;\n  }\n\n  /**\n   * @public\n   * traverse the words in the trie\n   * @param {function} cb\n   * @param {TrieNode} node\n   * @param {string} w\n   */\n  forEach(cb, node = this._root, w = '') {\n    if (typeof cb !== 'function') {\n      throw new Error('Trie.forEach expects a callback');\n    }\n\n    let word = w;\n    if (node.isEndOfWord()) {\n      cb(word);\n    }\n\n    node.children().forEach((child) => {\n      word += child.getChar();\n      this.forEach(cb, child, word); // depth-first search\n      word = word.substr(0, word.length - 1); // backward tracking\n    });\n  }\n\n  /**\n   * @public\n   * converts the trie into an array of words\n   * @returns {array}\n   */\n  toArray() {\n    const result = [];\n    this.forEach((word) => result.push(word));\n    return result;\n  }\n\n  /**\n   * @public\n   * @returns {number}\n   */\n  nodesCount() {\n    return this._nodesCount;\n  }\n\n  /**\n   * @public\n   * @returns {number}\n   */\n  wordsCount() {\n    return this._wordsCount;\n  }\n\n  /**\n   * @public\n   * clears the trie\n   */\n  clear() {\n    this._root = new TrieNode('');\n    this._nodesCount = 1;\n    this._wordsCount = 0;\n  }\n}\n\nmodule.exports = Trie;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/trie/src/trie.js?");

/***/ }),

/***/ "./node_modules/@datastructures-js/trie/src/trieNode.js":
/*!**************************************************************!*\
  !*** ./node_modules/@datastructures-js/trie/src/trieNode.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("/**\n * @datastructures-js/trie\n * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>\n * @license MIT\n */\n\n/**\n * @class TrieNode\n */\nclass TrieNode {\n  constructor(char) {\n    this._char = char;\n    this._isEndOfWord = false;\n    this._parent = null;\n    this._children = new Map();\n  }\n\n  /**\n   * @public\n   * @returns {string}\n   */\n  getChar() {\n    return this._char;\n  }\n\n  /**\n   * @internal\n   * @param {TrieNode} parentNode\n   */\n  setParent(parentNode) {\n    this._parent = parentNode;\n  }\n\n  /**\n   * @public\n   * @return {TrieNode}\n   */\n  getParent() {\n    return this._parent;\n  }\n\n  /**\n   * @internal\n   * @param {boolean} endOfWord\n   */\n  setEndOfWord(isEndOfWord) {\n    this._isEndOfWord = isEndOfWord;\n  }\n\n  /**\n   * @public\n   * @return {boolean}\n   */\n  isEndOfWord() {\n    return this._isEndOfWord;\n  }\n\n  /**\n   * @internal\n   * @param {string} char\n   */\n  addChild(char) {\n    const childNode = new TrieNode(char);\n    childNode.setParent(this);\n    this._children.set(char, childNode);\n  }\n\n  /**\n   * @internal\n   * @param {string} char\n   * @return {boolean}\n   */\n  removeChild(char) {\n    return this._children.delete(char);\n  }\n\n  /**\n   * @public\n   * @param {string} char\n   * @return {TrieNode}\n   */\n  getChild(char) {\n    return this._children.get(char) || null;\n  }\n\n  /**\n   * @public\n   * @param {string} char\n   * @return {boolean}\n   */\n  hasChild(char) {\n    return this._children.has(char);\n  }\n\n  /**\n   * @internal\n   * @return {Map}\n   */\n  children() {\n    return this._children;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  childrenCount() {\n    return this._children.size;\n  }\n}\n\nmodule.exports = TrieNode;\n\n\n//# sourceURL=webpack://todo-list/./node_modules/@datastructures-js/trie/src/trieNode.js?");

/***/ }),

/***/ "./node_modules/datastructures-js/index.js":
/*!*************************************************!*\
  !*** ./node_modules/datastructures-js/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Queue = __webpack_require__(/*! @datastructures-js/queue */ \"./node_modules/@datastructures-js/queue/index.js\");\nconst Stack = __webpack_require__(/*! @datastructures-js/stack */ \"./node_modules/@datastructures-js/stack/index.js\");\nconst { MinPriorityQueue, MaxPriorityQueue } = __webpack_require__(/*! @datastructures-js/priority-queue */ \"./node_modules/@datastructures-js/priority-queue/index.js\");\nconst { MinHeap, MaxHeap } = __webpack_require__(/*! @datastructures-js/heap */ \"./node_modules/@datastructures-js/heap/index.js\");\nconst Set = __webpack_require__(/*! @datastructures-js/set */ \"./node_modules/@datastructures-js/set/index.js\");\nconst { LinkedList, DoublyLinkedList } = __webpack_require__(/*! @datastructures-js/linked-list */ \"./node_modules/@datastructures-js/linked-list/index.js\");\nconst Trie = __webpack_require__(/*! @datastructures-js/trie */ \"./node_modules/@datastructures-js/trie/index.js\");\nconst { Graph, DirectedGraph } = __webpack_require__(/*! @datastructures-js/graph */ \"./node_modules/@datastructures-js/graph/index.js\");\nconst { BinarySearchTree, AvlTree } = __webpack_require__(/*! @datastructures-js/binary-search-tree */ \"./node_modules/@datastructures-js/binary-search-tree/index.js\");\n\nmodule.exports = {\n  Queue,\n  MinPriorityQueue,\n  MaxPriorityQueue,\n  Stack,\n  MinHeap,\n  MaxHeap,\n  Set,\n  LinkedList,\n  DoublyLinkedList,\n  Trie,\n  Graph,\n  DirectedGraph,\n  BinarySearchTree,\n  AvlTree\n};\n\n\n//# sourceURL=webpack://todo-list/./node_modules/datastructures-js/index.js?");

/***/ }),

/***/ "./src/controller/controller.js":
/*!**************************************!*\
  !*** ./src/controller/controller.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getTaskInput\": () => (/* binding */ getTaskInput),\n/* harmony export */   \"resetTaskInput\": () => (/* binding */ resetTaskInput)\n/* harmony export */ });\n/* harmony import */ var _model_tasks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model/tasks.js */ \"./src/model/tasks.js\");\n\n/**\n * @return \n */\nfunction getTaskInput() {\n    let inputs = document.getElementById('task-input');\n    let input = inputs.querySelectorAll('input, textarea');\n    input = Array.from(input).map((node) => node.value);\n\n    let option = document.getElementById('priority').value;\n\n    let task = new _model_tasks_js__WEBPACK_IMPORTED_MODULE_0__.default(0, ...input, option);\n    resetTaskInput();\n    return task;\n}\nfunction resetTaskInput() {\n    let inputs = document.getElementById('task-input');\n    let input = inputs.querySelectorAll('input, textarea');\n    for(let node of input) {\n        node.value = '';\n    }\n    document.getElementById('priority').value = '0';\n}\n\n\n\n\n//# sourceURL=webpack://todo-list/./src/controller/controller.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _controller_controller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./controller/controller.js */ \"./src/controller/controller.js\");\n/* harmony import */ var _model_timeline_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model/timeline.js */ \"./src/model/timeline.js\");\n/* harmony import */ var _view_display_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./view/display.js */ \"./src/view/display.js\");\n\n\n\n\nlet curr_timeline = _model_timeline_js__WEBPACK_IMPORTED_MODULE_1__.default;\ndocument.getElementById(\"task-submit-button\").addEventListener('click', (e) => {\n    let curr = (0,_controller_controller_js__WEBPACK_IMPORTED_MODULE_0__.getTaskInput)();\n    curr_timeline.appendTask(curr);\n    (0,_controller_controller_js__WEBPACK_IMPORTED_MODULE_0__.resetTaskInput)();\n    (0,_view_display_js__WEBPACK_IMPORTED_MODULE_2__.displayTimeline)(curr_timeline);\n});\n\n\n\n//# sourceURL=webpack://todo-list/./src/index.js?");

/***/ }),

/***/ "./src/model/tasks.js":
/*!****************************!*\
  !*** ./src/model/tasks.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/** Class representing a task. */\nclass Task {\n    /**\n     * Create a task.\n     * @param {number} id Number representing id of the task. id must be unique and a positive integer.\n     * @param {string} title Name of the task.\n     * @param {string} description Description of task or additional notes about the task.\n     * @param {Date} start_date Date object representing the start date of the task.\n     * @param {Date} due_date Date object representing the due date of the task.\n     * @param {number} priority Number representing the priority of the task from highest(0) to lowest(4).\n     */\n    constructor(id = -1, title = '', description = '', start_date = new Date(), due_date = new Date(), priority = 0) {\n        this._id = id;\n        this._title = title;\n        this._description = description;\n        this._dueDate = new Date(due_date);\n        this._startDate = new Date(start_date);\n        this._priority = priority;\n    }\n    /**\n     * Getters and setters.\n     */\n    get id() {\n        return this._id;\n    }\n    get title() {\n        return this._title;\n    }\n    get description() {\n        return this._description;\n    }\n    get dueDate() {\n        return this._dueDate;\n    }\n    get startDate() {\n        return this._startDate;\n    }\n    get priority() {\n        return this._priority;\n    }\n    set title(title) {\n        this._title = title;\n    }\n    set description(description) {\n        this._description = description;\n    }\n    set dueDate(due_date) {\n        this._dueDate = due_date;\n    }\n    set startDate(start_date) {\n        this._startDate = start_date;\n    }\n    set priority(priority) {\n        this._priority = priority;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Task);\n\n//# sourceURL=webpack://todo-list/./src/model/tasks.js?");

/***/ }),

/***/ "./src/model/timeline.js":
/*!*******************************!*\
  !*** ./src/model/timeline.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var datastructures_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! datastructures-js */ \"./node_modules/datastructures-js/index.js\");\n/* harmony import */ var datastructures_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(datastructures_js__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * A timeline singleton. \n */\nconst timeline = (() => {\n    /**\n     * BST representing the timeline of tasks. Custom comparator for dates.\n     */\n    let bst = new datastructures_js__WEBPACK_IMPORTED_MODULE_0__.AvlTree((first, second) => {\n        if(first.date < second.date) return -1;\n        if(first.date > second.date) return 1;\n        return 0;\n    });\n    /**\n     * Add a new task to the timeline.\n     * @param {Date} date Date object representing the time \n     * on the timeline(usually equals to the start date of task).\n     * @param {Task} task Task object representing the task.\n     */\n    const appendTask = (task, date = task.startDate) => {\n        bst.add({task, date});\n    };\n    \n    const getTimeline = () => {\n        return bst.toArray();\n    };\n    return {appendTask, getTimeline};\n})();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (timeline);\n\n//# sourceURL=webpack://todo-list/./src/model/timeline.js?");

/***/ }),

/***/ "./src/view/display.js":
/*!*****************************!*\
  !*** ./src/view/display.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"displayTimeline\": () => (/* binding */ displayTimeline)\n/* harmony export */ });\nconst displayTimeline = (timeline) => {\n    let task_arr = timeline.getTimeline();\n    for(let i = 0; i < task_arr.length; ++i) {\n        let node = document.createElement('div');\n        node.classList = 'task-card';\n        let title = document.createElement('h1');\n        title.classList = 'task-title';\n        title.textContent = task_arr[i].task.title;\n        let description = document.createElement('div');\n        description.classList = 'task-description';\n        description.textContent = task_arr[i].task.description;\n        node.appendChild(title);\n        node.appendChild(description);\n        document.querySelector('body').appendChild(node);\n    }\n}\n\n\n//# sourceURL=webpack://todo-list/./src/view/display.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/index.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;